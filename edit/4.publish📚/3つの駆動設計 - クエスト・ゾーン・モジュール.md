# 3つの駆動設計 - クエスト・ゾーン・モジュール


## はじめに

本書は、humanityプロジェクトにおける**具体的な設計の指針**を示す。

生物学的自己組織化という原理（How）を、実際のシステム設計にどう落とし込むか（What）。

その答えが、**3つの駆動設計**である：

1. **クエスト駆動設計** - 意思の発現
2. **ゾーン駆動設計** - 環境応答
3. **モジュール駆動設計** - 動的接続

**これらは独立した概念ではなく、生物学的自己組織化という単一の原理の3つの側面である。**

---

## 第1章: 3つの設計論の統合

### 1.1 なぜ3つの設計論なのか

生物学的自己組織化には、3つの要素が必要だった：

1. **遺伝子発現制御** - 何を発現させるか
2. **環境応答** - どこで発現するか
3. **細胞膜の形成** - どう接続するか

これを人工システムに適用すると：

| 生物学 | 人工システム | 設計論 | 問い |
|--------|------------|--------|------|
| 遺伝子発現制御 | 意思の駆動 | **クエスト駆動** | **何を**実現するか |
| 環境応答 | 場の提供 | **ゾーン駆動** | **どこで**発動するか |
| 細胞膜の形成 | 手段の提供 | **モジュール駆動** | **どう**実現するか |

### 1.2 3つはどう組み合わさるのか

**統合的な動作フロー：**

```
1. ユーザーが「ゾーン」（物理空間）に入る
   ↓
2. 「ゾーン」が状態を提供する
   - その場所に残されたメッセージ
   - その場所にあるモノ（アフォーダンス）
   ↓
3. 「クエスト」が発動する
   - 「段ボールを2階に運んでほしい」
   - ユーザーは引力によって突き動かされる
   ↓
4. 利用可能な「モジュール」が見える
   - 冷蔵庫（保存できる、温度計測できる）
   - プリンター（印刷できる）
   - 人間（料理できる）
   ↓
5. LLMが最適な「モジュールの組み合わせ」を判断
   - 状況に応じて動的に
   - その場でMCP経由で取得
   ↓
6. 実行 → 結果 → 学習
```

**図解：**

```
    ┌─────────────┐
    │   ゾーン    │ ← 場を提供（Where）
    │  （玄関）   │
    └──────┬──────┘
           │ 入る
    ┌──────▼──────┐
    │  クエスト   │ ← 意思を駆動（Will）
    │「運んで」   │
    └──────┬──────┘
           │ 発動
    ┌──────▼──────┐
    │  モジュール  │ ← 手段を提供（How）
    │冷蔵庫・人間 │
    └──────┬──────┘
           │ 組み合わせ
    ┌──────▼──────┐
    │  LLM判断   │
    │  + MCP実行  │
    └─────────────┘
```

### 1.3 具体例：カレーを作る

#### 従来のタスク型システム：

- レシピアプリを開く
- 材料をチェック
- タイマーをセット
- 手順を一つずつ実行

→ ユーザーが能動的にアプリを開き、探し、操作する必要がある

#### Humanity（3つの設計論統合）：

1. **ゾーン**: キッチンに入る
   - スマートフォンのライブアクティビティに自動で表示される

2. **クエスト**: 「カレーが作りたい」（引力）
   - タスクではなく、「やりたい」という意思
   - 引き寄せられるように感じる

3. **モジュール認識**:
   - 冷蔵庫（材料リスト取得）
   - 電子レンジ（加熱）
   - IHコンロ（調理）
   - 人間（判断・実行）
   - これらのアフォーダンスが「見える」状態になる

4. **LLM判断**:
   - 冷蔵庫から材料確認
   - 足りないものを提案
   - 調理手順を動的生成
   - 人間とモジュールの最適な組み合わせを判断

5. **実行**: その場で必要なモジュールをMCP経由で取得・連携

### 1.4 3つが揃わないと機能しない

**クエストだけでは:**
- 「カレーを作りたい」という意思はあるが、
- **どこで？何を使って？**が不明
- → 意思だけでは実現できない

**ゾーンだけでは:**
- キッチンという場所があるが、
- **何をする？どう実現する？**が不明
- → 場所だけでは何も起きない

**モジュールだけでは:**
- 道具はあるが、
- **誰が使う？なぜ使う？どこで使う？**が不明
- → 手段だけでは組み合わせが決まらない

**3つが統合されて初めて、事前定義なしの動的な自己組織化が起きる。**

---

## 第2章: クエスト駆動設計 - 意思の発現

### 2.1 クエストとは何か

**クエストとは、引力を持つもの。**

タスク（Can - できる）ではなく、クエスト（Will - やりたい）が人を突き動かす。

#### タスクとクエストの違い

| | タスク | クエスト |
|---|---|---|
| 動機 | Can（できる） | Will（やりたい） |
| 方向性 | 自分から動く | 引き寄せられる |
| 処理 | 論理的に考える | 突き動かされる |
| 脳の部位 | 外側の脳 | 内側の脳 |

**クエストの本質：**
- 自分から向かうのではない
- **引き寄せられる**
- 気づいたらそこにいる
- 「この人と話さないと、このアイディアは今消えちゃう」

### 2.2 クエストの身体感覚

クエストは論理ではなく、**身体で感じるもの**である。

#### 突き動かされる感覚

- 「この人と話さないと、このアイディアは今消えちゃう」
- 「このフレーズが逃げる前に」
- 自分から目で追ったわけじゃない
- **目が離せなかった**

#### 摩擦係数の比喩

クエストには、物理法則のような段階がある：

1. **引力に引き寄せられる**（初動・最大摩擦）
   - 最初の一歩が最も重い
   - しかし引力が背中を押す

2. **走り出す**（摩擦が減る）
   - 動き始めると楽になる
   - 加速していく

3. **走り続ける**（慣性）
   - 止まろうとしても止まれない
   - 夢中になっている

4. **気づいたら到着**
   - 「気づいたらここまで来ていた」
   - 自分で選んだというより、導かれた感覚

### 2.3 誰もが知っているクエスト

実は、誰もがクエスト体験をしている。ただし多くの場合、**疑似体験**として。

#### 日常のクエスト体験

**恋愛**：運命だと感じる瞬間
- 「この人だ」という直感
- 論理では説明できない引力
- 突き動かされる感覚

**1950年代ロックンロール**：突き動かされた世代
- 「お金になるかとか関係ない」
- 「私はこれをやらないといけないんだみたいなロックンロール」
- 意思がある

**高校野球・甲子園**
- 「甲子園に行く」という引力
- 先輩から後輩へ受け継がれる意思
- 合理性を超えた情熱

**ドラゴンクエスト**：主人公になれる
- 「勇者として世界を救う」
- ゲームの中でクエスト体験
- 本物の突き動かされる感覚

**みんなクエストしてる。**

しかし多くは、ゲーム、スポーツ、恋愛という限定された場での体験だ。

生成AI時代の課題は、**日常のあらゆる場面で、本物のクエスト体験を取り戻すこと**である。

### 2.4 運命という勘違い

クエストには、不思議な特徴がある。

> 「あ、もうこれは運命だとか言っちゃっていいじゃないですか」

- 論理的には説明できない
- でも感覚は本物
- **この勘違いが人を突き動かす**

「運命だ」
「これしかない」
「今しかない」

客観的に見れば、偶然かもしれない。たまたまかもしれない。

しかし、**その瞬間の本人にとっては、運命以外の何物でもない。**

この「運命という勘違い」こそが、クエストの設計において最も重要な要素である。

論理で納得させるのではない。
身体が「これだ」と感じる状態を作る。

### 2.5 生物学的対応：遺伝子発現制御

生物は「**どの遺伝子を発現させるか**」を状態に応じて決定する。

人工システムでは、これが「**クエスト**」に対応する。

- 環境（ゾーン）の状態によって、発動するクエストが変わる
- DNAが最小限の情報しか持たないように、クエストも事前に全てを定義しない
- その場の状態に応じて、「これをやりたい」という意思が発現する

### 2.6 3つの設計論における位置づけ

- クエストが「**何を**実現するか」を定義
- ゾーンが「**どこで**発動するか」を決定
- モジュールが「**どう**実現するか」を提供

**例：**
- **クエスト**: 「段ボールを2階に運んでほしい」（何を）
- **ゾーン**: 玄関に入ったときに発動（どこで）
- **モジュール**: 人間の「運ぶ」能力を使う（どう）

### 2.7 クエストの実装原則

クエストを設計するには、4つの原則がある：

1. **引力を持たせる**
   - ❌ 「〇〇ポイント獲得」
   - ✅ 「今逃したら二度と出会えない」

2. **時間的切迫感**
   - 「今」「このフレーズが逃げる前に」
   - 先延ばしできない感覚

3. **運命感**
   - 「これは運命だ」という勘違いを誘発
   - 論理的には説明できないが、感覚は本物

4. **突き動かす**
   - ユーザーが「選んだ」ではなく
   - 「選ばされた」と感じさせる

### 2.8 クエストとAIの関係

**AIが得意なのはCan**
- 「これはできる」
- スキル・能力
- 論理的処理

**人間のクエストはWill**
- 「お金になるかとか関係ない」
- 「私はこれをやらないといけないんだみたいなロックンロール」
- **意思がある**

生成AI時代だからこそ、人間の「Will」を駆動するクエスト設計が重要になる。

---

## 第3章: ゾーン駆動設計 - 環境応答

### プロローグ：デジタル情報はどこにあるのか

私たちは、デジタル情報がどこにあるか答えられない。

「あのファイル、どこだっけ？」
「メモはどのアプリに入れたっけ？」
「タスクは…Notionだったか、Todoistだったか？」

**デジタル情報には場所がない。**

一方、現実世界の情報には場所がある。

「あの棚にあったな」
「玄関に段ボールが置いてある」
「リビングのテーブルにメモが置いてある」

私たちは、物理世界では「場所」で情報を管理している。しかしデジタル情報は、スマホやPCの「中」にあり、場所とは切り離されている。

**ゾーン駆動設計は、この分離を解消する。**

デジタル情報を物理空間に紐づけ、「その場所に行くと情報が見える」状態を作る。これが、ゾーンという概念の出発点である。

### 3.1 ゾーンとは何か

**ゾーン = 物理空間に紐づくデジタル情報の集合体**

#### ゾーンに含まれる2つの要素：

1. **その場所に残されたメッセージ/クエスト**
   - 「段ボールを2階に運んでほしい」
   - 「今日の買い物リスト」
   - 「この部屋でやるべきタスク」

2. **そのゾーンの中にあるモノのアフォーダンス（能力）**
   - 冷蔵庫：「保存できる」「温度を計測できる」
   - プリンター：「印刷できる」
   - 電子レンジ：「加熱できる」
   - 人間：「料理できる」「判断できる」

**重要：ハードウェア・ソフトウェア・人間を区別しない。**

すべてが「そのゾーンに存在するノード」として、自分の能力を提示する。

### 3.2 ゾーンに入ると何が起きるか

**ゾーンに入る = その場所の「やるべきこと（クエスト）」と「できること（アフォーダンス）」の両方が見える状態になる**

#### 例：玄関というゾーンに入ったとき

- スマートフォンのライブアクティビティに「段ボールを2階に運んでほしい」というメッセージが表示される
- そのゾーンにある物理的なモノ（冷蔵庫、プリンター、棚など）のアフォーダンスが「見える」状態になる
- 人がいれば、その人の能力（「料理できる」「判断できる」）も見える

**ゾーンを離れると、別のゾーンの情報に切り替わる。**

リビングに移動すれば、リビングのクエストとアフォーダンスが表示される。常に「**今いる場所**」の情報だけが見える。

### 3.3 従来のソフトウェアとの違い

| 観点 | 従来のソフトウェア | ゾーン駆動設計 |
|---|---|---|
| **情報の場所** | スマホ/PCの中 | 物理空間に紐づく |
| **情報の取得** | アプリを開いて探す | その場所に行くと自動で見える |
| **情報の管理** | アプリごとに分散 | 場所ごとに統合 |
| **ハード・ソフトの区別** | 明確に区別される | 区別されない（すべてノード） |

### 3.4 生物学的対応：環境依存の発現

生物は「**どこにいるか**」によって、同じDNAでも異なる細胞になる。

- 心臓細胞か肝臓細胞かは、周囲の環境シグナルによって決まる
- 同一のDNAを持つ細胞でも、環境によって発現する遺伝子が変わる

人工システムでは、これが「**ゾーン**」に対応する。

- ゾーンが環境を提供する
- その環境に応じてクエストが発動
- その環境で利用可能なモジュールが認識される

### 3.5 3つの設計論における位置づけ

- ゾーンがクエストを「**発動**」させる
- ゾーンが利用可能なモジュールを「**フィルタリング**」する
- ゾーンが状態を「**保持**」する（時間を超えたメッセージ）

**ゾーンがないと:**
- クエストはいつ発動すればいいかわからない
- モジュールは世界中の全てが候補になってしまう（絞り込めない）
- メッセージを「この場所で」伝えることができない

**ゾーンという境界があるから、「今この場所にあるもの」が特定できる。**

### 3.6 時間を超えるメッセージ

ゾーンの最も重要な特性は、**時間を超えてメッセージを届ける**ことである。

#### ゾーンは状態を持つ

例：玄関というゾーン

- 昨日、誰かが「段ボールを2階に運んでほしい」というメッセージを残した
- 今日、別の人が玄関に入ると、そのメッセージを受け取る
- メッセージを受け取った人が実行すると、ゾーンの状態が更新される

**ゾーンは、時間を超えてメッセージを届ける。**

昨日の誰かが、明日の私に向けて情報を残せる。それがゾーンに紐づいて保存される。

#### カレンダーやTodoリストとは異なる

カレンダーは「9時に会議」という時間ベースの拘束。Todoリストは「いつかやるべきこと」のリスト。

ゾーンは、**場所に入った瞬間に、その場所で必要なことが見える。**

#### 全てのことはメッセージ

荒井由実（ユーミン）の「優しさに包まれたなら」に、重要な洞察がある。

> 目に映る全てのことはメッセージ

星も、カーテンからの木洩れ陽も、メッセージを送っている。私たちは受け取っているのに、気づいていなかった。

**ゾーン駆動設計は、このメッセージを明示化する。**

- 玄関に置かれた段ボール → 「運んでほしい」というメッセージ
- キッチンの食材 → 「料理してほしい」というメッセージ
- リビングの本 → 「読んでほしい」というメッセージ

物理世界のオブジェクトは、常にメッセージを発している。ゾーンは、そのメッセージをデジタル情報として明示化し、適切なタイミング（その場所に入ったとき）で届ける。

### 3.7 FF14のメタファー：認知者が通った時だけ発現

ファイナルファンタジー14（FF14）には、重要な設計思想がある。

従来のゲーム設計：
- 花のオブジェクトは常に揺れていた
- 処理負荷が高く、ゲームが重くなった

FF14の発想転換：
- **ユーザー（認知者）が近づいたときだけ、花が揺れる**
- ユーザーが離れると、花は止まる

花自体に「私、揺れることができますよ」という能力（アフォーダンス）が記述されている。しかし、その能力は**ユーザーが近づいたときだけ発現する。**

**ゾーン駆動設計も同じ原理である。**

- 冷蔵庫は常にアフォーダンスを持っている
- しかし、そのアフォーダンスが「見える」「使える」状態になるのは、**人がそのゾーンに入ったとき**

### 3.8 実装のポイント

#### ゾーン境界の検知
- BLE（Bluetooth Low Energy）ビーコン
- UWB（Ultra-Wideband）
- GPS / Wi-Fi位置情報
- NFCタグ

#### ゾーンYAMLの設計
```yaml
zone_id: "entrance_01"
zone_name: "玄関"

quests:
  - id: "quest_001"
    message: "段ボールを2階に運んでください"
    created_by: "tanaka"
    status: "active"

nodes:
  - node_id: "refrigerator_01"
    type: "hardware"
    capabilities:
      - action: "store"
      - action: "measure_temperature"

  - node_id: "human_tanaka"
    type: "human"
    capabilities:
      - action: "cook"
      - action: "carry"
```

#### ライブアクティビティへの表示
- iOSのライブアクティビティ（ロック画面に常時表示）
- Androidのウィジェット
- スマートウォッチの通知

#### オフライン動作の重要性
- NFCタグにゾーンYAMLへのポインタを記録
- ローカルLLMでアフォーダンスを解釈
- ネットワーク接続なしでも動作

---

## 第4章: モジュール駆動設計 - 動的接続

### プロローグ：なぜ「何でもできる」では何も作れないのか

**「AIがあれば何でもできますよ」**

この言葉を聞いて、あなたは何を作りたいと思うだろうか。

おそらく、何も思い浮かばない。「何でもできる」と言われても、人は何をしたいのか分からない。無限の可能性を前にして、人は立ち尽くすだけだ。

**しかし、藤子・F・不二雄は違った。**

『ドラえもん』の作者である藤子先生は、数百の秘密道具を生み出し、その一つ一つから無数の物語を紡ぎ出した。タケコプター、どこでもドア、タイムふろしき、スモールライト。

**重要なのは、秘密道具が物語を生んだということだ。**

物語のために秘密道具が作られたのではない。秘密道具があるから、「あ、こんな話も書ける」「こういう使い方もできるな」と気づく。道具の存在が、物語の可能性を開く。

劇場版を見れば分かる。同じタイムふろしきでも、『のび太の宇宙小戦争』での使い方と『のび太と鉄人兵団』での使い方は全く違う。アニメ版の「困った→道具を出す→解決」という単純なパターンではなく、複数の道具を状況に応じて組み合わせ、創造的に使う。

**これは、ソフトウェア設計の本質を突いている。**

人は、具体的なモジュール（秘密道具）がなければ、自分が何を作りたいのか考えられない。逆に、モジュールの存在と組み合わせの可能性を知ることで、「もしかしたらこういうことできるかも」と閃く。

この洞察が、モジュール駆動設計の出発点である。

### 4.1 モジュール（秘密道具）とは何か

**モジュール = 「できること」を提示する単位**

- ハードウェア、ソフトウェア、人間を区別しない
- すべてがアフォーダンスを持つノード
- 単独でも機能するが、組み合わせで真価を発揮

#### 秘密道具のメタファー

ドラえもんの秘密道具がモジュールの本質を示している：

- タケコプター：空中移動モジュール
- どこでもドア：瞬間移動モジュール
- タイムふろしき：時間操作モジュール
- スモールライト：サイズ変更モジュール

一つ一つは単純な機能を持つ。しかし組み合わせることで、無限の可能性が生まれる。

### 4.2 四次元ポケットとMCP

#### 一般的な誤解

「四次元ポケット = 秘密道具を収納する空間」

ドラえもんは未来デパートで購入した道具を四次元ポケットに格納している、という公式設定。

#### 実際の本質

**四次元ポケット = MCP/APIへのインターフェース（動的取得の仕組み）**

ドラえもんがのび太の要望を聞いた瞬間、こう動いている：

1. **要望を解析**（プロンプト処理）
   - 「ジャイアンにいじめられた！」→「対抗手段が必要」

2. **MCP経由でモジュール/APIを検索**
   - 四次元ポケットに「手を突っ込む」動作

3. **適切なものを取得（または生成）**
   - npmレジストリから取得するように
   - その場でモジュールを呼び出す

4. **のび太に渡す**
   - 「はい、空気砲！」

**「未来デパートで購入済み」ではない。その場でレジストリから動的に取得している。**

#### 未来デパートの正体

**未来デパート = npmレジストリ、GitHub、MCPサーバー群**

- 世界中の開発者（未来の発明家）が作ったモジュールが登録されている
- ドラえもんはそこから動的に取得している
- 「購入」という表現は、のび太向けの説明
- 実際は「API呼び出し」「モジュール取得」

```
ユーザーの要望（のび太）
  ↓
プロンプト解析
  ↓
LLM（ドラえもんの思考・判断）
  ↓
MCP（四次元ポケット）
  ↓
モジュール/APIレジストリ（未来デパート）
  ↓
秘密道具（モジュール）
```

### 4.3 劇場版の組み合わせの妙

**アニメ版の定型パターン:**
- のび太が困る
- 「助けてドラえもん」
- 秘密道具を使う
- 解決（または調子に乗ってしっぺ返し）

単純で予測可能。

**劇場版は違う:**

劇場版では、複数の秘密道具が登場し、状況に応じて組み合わせ方が変わる。

- タイムふろしきの使い方は『宇宙小戦争』と『鉄人兵団』で全く異なる
- どこでもドアは単なる移動手段ではなく、戦略的に使われる
- スペアポケットから予想外の道具が出てくる

**物語という大きな冒険の中で、秘密道具をどう使うかが都度変わる。**

これは固定的なワークフローではない。状況に応じて、組み合わせて、創造的に使う。

**これが、クエスト駆動型設計の本質だ。**

### 4.4 生物学的対応：細胞膜の動的生成

生物の細胞は、接続すべき相手に応じて受容体を動的に生成する。

- 「細胞Aと細胞Bをこの形状で接続せよ」という指示がDNAに書かれているわけではない
- 細胞Aが「自分はこういう分子を持っている」と提示する
- 細胞Bがそれに応じて受容体を生成する
- 接続が形成される

人工システムでは、モジュールが状況に応じて動的に取得・組み合わされる。

### 4.5 3つの設計論における位置づけ

- モジュールが「**できること**」を提供
- クエストの達成に必要なモジュールを動的に取得
- ゾーン内で利用可能なモジュールを認識

**例：**
- **ゾーン**: キッチン（どこで）
- **クエスト**: カレーを作りたい（何を）
- **モジュール**: 冷蔵庫、IHコンロ、人間の「料理」能力（どう）

### 4.6 モジュールの組み合わせ理論

#### なぜモジュールが必要なのか

**「何でもできる」の罠:**

AIに「何でもできますよ」と言われても、人は何も思いつかない。可能性が無限すぎて、逆に何も選べない。

**モジュールという「制約」が創造を生む:**

しかし、「タケコプターがあります」「どこでもドアがあります」と具体的に提示されると、人は閃く。

- 「タケコプターとどこでもドアを組み合わせたら？」
- 「スモールライトで小さくなってから、どこでもドアで入り込めば？」
- 「タイムふろしきで過去の状態に戻せば？」

**具体的なモジュールの存在が、組み合わせの可能性を開く。**

藤子・F・不二雄先生も同じだった。秘密道具があるから、「こんな話も書ける」「あんな話も書ける」と次々にアイデアが湧いた。

**人は、何かしらの秘密道具のような形でモジュール化されていないと、自分が何をしたいのか考えられない。**

逆に、モジュールの組み合わせによって、「もしかしたらこういうことできるかも」と閃いたり、実現できたりする。

#### RPGの装備メタファー

**剣、魔法、回復薬、地図**

RPGゲームを想像してほしい。プレイヤーは装備を選ぶ。

- 剣：攻撃モジュール
- 魔法：遠距離攻撃・支援モジュール
- 回復薬：HP回復モジュール
- 地図：情報取得モジュール

これらは単独でも機能する。しかし、組み合わせることで、全く異なる冒険が生まれる。

- 剣＋回復薬：接近戦メインの力押しスタイル
- 魔法＋地図：情報を集めて遠距離から戦略的に
- 剣＋魔法＋回復薬＋地図：バランス型の探索

**時代が変われば、同じ装備でも全く違う冒険になる。**

これが、モジュール駆動設計の本質だ。固定的なワークフローではなく、状況に応じた動的な組み合わせ。

#### モジュール設計の原則

1. **モジュールは単独でも動く**
   - 各モジュールは独立して機能する
   - タケコプターだけでも空を飛べる

2. **組み合わせで新しい可能性が生まれる**
   - 真の価値は、組み合わせた時に発揮される
   - タケコプター × どこでもドア × スモールライト

3. **文脈依存で動的に選択される**
   - 「どの組み合わせが正解」と事前に決めない
   - 状況を見て、その場で判断する

4. **相互学習が可能**
   - どの組み合わせが有効だったかを記録
   - 次回に活かす

### 4.7 タスク型 vs クエスト型モジュール

同じモジュールでも、タスク型とクエスト型では使い方が根本的に異なる。

#### タスク型モジュールの特徴

- **効率的な処理を目指す**
  - 入力→処理→出力が明確
  - 最適化が目標
  - エラーは避けるべきもの

**例：在庫管理モジュール**
- 在庫数を正確に管理
- 規定値を下回ったら自動発注
- 効率的で予測可能

#### クエスト型モジュールの特徴

- **探求、相関発見を目指す**
  - 「なぜ」を問う
  - 予想外の発見を歓迎
  - エラーは新しい道

**例：在庫探索モジュール**
- なぜこの商品が買われたのか
- どんな組み合わせが生まれるか
- 季節性、顧客の購買パターン、関連商品の相関を発見

#### プロンプト設計による違い

**同じ在庫管理システムでも、プロンプトで変わる:**

**タスク型プロンプト：**
```
在庫が規定値を下回ったら発注してください
```
→ 決められた処理を実行

**クエスト型プロンプト：**
```
在庫の動きから、顧客の購買パターン、季節性、
関連商品の相関を見つけてください。
予想外の発見があれば報告してください
```
→ 探索と発見を促す

**同じモジュール、異なる使い方。**

これが、秘密道具駆動設計の柔軟性だ。モジュールは同じでも、プロンプト（使い方の指示）によって、タスク型にもクエスト型にもなる。

### 4.8 実装のポイント

#### アフォーダンスの記述（YAML/JSON）

```yaml
node_id: "printer_A"
capabilities:
  - action: "print"
    parameters:
      - name: "document"
        type: "file"
      - name: "color"
        type: "boolean"
```

```yaml
node_id: "human_tanaka"
capabilities:
  - action: "cook"
    skills: ["curry", "pasta"]
  - action: "judge"
    domains: ["business", "technology"]
```

#### MCPによる動的取得

- JSON-RPCベースの通信規格
- ノードが提示するアフォーダンスを読み取る
- ノード間でメッセージを伝達する
- ノードの呼び出しを実行する

#### LLMによる組み合わせ判断

LLMは、状態と目的に応じて、どのモジュールをどの順序で組み合わせるかを判断する。

- 現在の状況を分析
- 目的を理解
- 利用可能なモジュールを検索
- 最適な組み合わせを選択
- 実行
- 結果を評価
- 次回に活かす

#### 既存技術スタックの活用

- **npm/yarn**: JavaScriptパッケージ
- **pip**: Pythonパッケージ
- **MCP（Model Context Protocol）**: LLMの統合
- **RESTful API、GraphQL**: 外部サービスとの連携
- **WebAssembly（WASM）**: 環境を選ばない実行


---

## エピローグ: 3つの設計論から実装へ

### 3つは独立していない

クエスト駆動、ゾーン駆動、モジュール駆動。

これらは別々の概念ではない。**生物学的自己組織化という単一原理の3つの側面**である。

| 設計論 | 生物学的対応 | 役割 | 問い |
|--------|------------|------|------|
| **クエスト駆動** | 遺伝子発現制御 | 意思の駆動 | 何を |
| **ゾーン駆動** | 環境応答 | 場の提供 | どこで |
| **モジュール駆動** | 細胞膜の形成 | 手段の提供 | どう |

### 3つが統合されて初めて動く

- **クエストだけ**: 意思はあるが、場所も手段も不明
- **ゾーンだけ**: 場所はあるが、意思も手段も不明
- **モジュールだけ**: 手段はあるが、意思も場所も不明

**3つが統合されて初めて、事前定義なしに動的に接続するシステムが実現する。**