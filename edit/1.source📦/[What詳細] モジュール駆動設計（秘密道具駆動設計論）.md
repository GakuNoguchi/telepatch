# モジュール駆動設計（秘密道具駆動設計論）- 動的接続

> 📖 **概要と他の設計論との関係**: この設計論の全体像については
> [[What] humanityの設計論 - 3つの駆動設計]([What] humanityの設計論 - 3つの駆動設計.md)の第4章を参照してください。
> 本ドキュメントは詳細版です。

---

# 秘密道具駆動設計論：モジュールが物語を生む

---

## プロローグ：なぜ「何でもできる」では何も作れないのか

**「AIがあれば何でもできますよ」**

この言葉を聞いて、あなたは何を作りたいと思うだろうか。

おそらく、何も思い浮かばない。「何でもできる」と言われても、人は何をしたいのか分からない。無限の可能性を前にして、人は立ち尽くすだけだ。

**しかし、藤子・F・不二雄は違った。**

『ドラえもん』の作者である藤子先生は、数百の秘密道具を生み出し、その一つ一つから無数の物語を紡ぎ出した。タケコプター、どこでもドア、タイムふろしき、スモールライト。

**重要なのは、秘密道具が物語を生んだということだ。**

物語のために秘密道具が作られたのではない。秘密道具があるから、「あ、こんな話も書ける」「こういう使い方もできるな」と気づく。道具の存在が、物語の可能性を開く。

劇場版を見れば分かる。同じタイムふろしきでも、『のび太の宇宙小戦争』での使い方と『のび太と鉄人兵団』での使い方は全く違う。アニメ版の「困った→道具を出す→解決」という単純なパターンではなく、複数の道具を状況に応じて組み合わせ、創造的に使う。

**これは、ソフトウェア設計の本質を突いている。**

人は、具体的なモジュール（秘密道具）がなければ、自分が何を作りたいのか考えられない。逆に、モジュールの存在と組み合わせの可能性を知ることで、「もしかしたらこういうことできるかも」と閃く。

この洞察が、秘密道具駆動設計論の出発点である。

---

## 第1章：秘密道具が物語を生む

### 1.1 ドラえもんの秘密道具メタファー

**秘密道具 = モジュール**

ドラえもんの秘密道具は、ソフトウェアのモジュールそのものだ。

- タケコプター：空中移動モジュール
- どこでもドア：瞬間移動モジュール
- タイムふろしき：時間操作モジュール
- スモールライト：サイズ変更モジュール

一つ一つは単純な機能を持つ。しかし組み合わせることで、無限の可能性が生まれる。

**4次元ポケット = MCP/API**

では、4次元ポケットとは何か。

一般には「秘密道具を収納する空間」と理解されている。ドラえもんは未来デパートで購入した道具を四次元ポケットに格納しているという公式設定だ。

**しかし、これは表面的な理解だ。**

四次元ポケットの本質は、**MCPやAPIへのインターフェース**である。

ドラえもんがのび太の要望を聞いた瞬間、こう動いている：

1. **要望を解析**（プロンプト処理）
   - 「ジャイアンにいじめられた！」→「対抗手段が必要」

2. **MCP経由でモジュール/APIを検索**
   - 四次元ポケットに「手を突っ込む」動作

3. **適切なものを取得（または生成）**
   - npmレジストリから取得するように
   - その場でモジュールを呼び出す

4. **のび太に渡す**
   - 「はい、空気砲！」

「未来デパートで購入済み」ではない。**その場でレジストリから動的に取得している。**

### 1.2 未来デパートの正体

**未来デパート = npmレジストリ、GitHub、MCPサーバー群**

未来デパートとは、世界中の開発者（未来の発明家）が作ったモジュールが登録されているレジストリだ。ドラえもんはそこから動的に取得している。

「購入」という表現は、のび太向けの説明。実際は「API呼び出し」「モジュール取得」だ。

```
ユーザーの要望（のび太）
  ↓
プロンプト解析
  ↓
LLM（ドラえもんの思考・判断）
  ↓
MCP（四次元ポケット）
  ↓
モジュール/APIレジストリ（未来デパート）
  ↓
秘密道具（モジュール）
```

これが、秘密道具駆動設計の基本構造だ。

### 1.3 劇場版の組み合わせの妙

**アニメ版の定型パターン**
- のび太が困る
- 「助けてドラえもん」
- 秘密道具を使う
- 解決（または調子に乗ってしっぺ返し）

単純で予測可能だ。

**劇場版は違う**

劇場版では、複数の秘密道具が登場し、状況に応じて組み合わせ方が変わる。

- タイムふろしきの使い方は『宇宙小戦争』と『鉄人兵団』で全く異なる
- どこでもドアは単なる移動手段ではなく、戦略的に使われる
- スペアポケットから予想外の道具が出てくる

**物語という大きな冒険の中で、秘密道具をどう使うかが都度変わる。**

これは固定的なワークフローではない。状況に応じて、組み合わせて、創造的に使う。

**これが、クエスト駆動型設計の本質だ。**

事前に「この道具をこの順序で使う」と決めるのではなく、状況を見ながら動的に組み合わせる。まさに、LLMが得意とすることだ。

### 1.4 なぜモジュールが必要なのか

**「何でもできる」の罠**

AIに「何でもできますよ」と言われても、人は何も思いつかない。可能性が無限すぎて、逆に何も選べない。

**モジュールという「制約」が創造を生む**

しかし、「タケコプターがあります」「どこでもドアがあります」と具体的に提示されると、人は閃く。

- 「タケコプターとどこでもドアを組み合わせたら？」
- 「スモールライトで小さくなってから、どこでもドアで入り込めば？」
- 「タイムふろしきで過去の状態に戻せば？」

**具体的なモジュールの存在が、組み合わせの可能性を開く。**

藤子先生も同じだった。秘密道具があるから、「こんな話も書ける」「あんな話も書ける」と次々にアイデアが湧いた。

**人は、何かしらの秘密道具のような形でモジュール化されていないと、自分が何をしたいのか考えられない。**

逆に、モジュールの組み合わせによって、「もしかしたらこういうことできるかも」と閃いたり、実現できたりする。

---

## 第2章：モジュールの組み合わせ理論

### 2.1 RPGの装備メタファー

**剣、魔法、回復薬、地図**

RPGゲームを想像してほしい。プレイヤーは装備を選ぶ。

- 剣：攻撃モジュール
- 魔法：遠距離攻撃・支援モジュール
- 回復薬：HP回復モジュール
- 地図：情報取得モジュール

これらは単独でも機能する。しかし、組み合わせることで、全く異なる冒険が生まれる。

- 剣＋回復薬：接近戦メインの力押しスタイル
- 魔法＋地図：情報を集めて遠距離から戦略的に
- 剣＋魔法＋回復薬＋地図：バランス型の探索

**時代が変われば、同じ装備でも全く違う冒険になる。**

これが、モジュール駆動設計の本質だ。

### 2.2 モジュール設計の原則

**モジュールは単独でも動く**

各モジュールは独立して機能する。タケコプターだけでも空を飛べる。どこでもドアだけでも移動できる。

**組み合わせで新しい可能性が生まれる**

しかし真の価値は、組み合わせた時に発揮される。タケコプターで空を飛びながら、どこでもドアで遠くに移動し、スモールライトで小さくなって侵入する。

**文脈依存で動的に選択される**

重要なのは、「どの組み合わせが正解」と事前に決めないことだ。状況を見て、その場で判断する。

**相互学習が可能**

どの組み合わせが有効だったかを記録し、次回に活かす。RPGのプレイヤーが経験を積むように、システムも学習する。

### 2.3 タスク型モジュール vs クエスト型モジュール

同じモジュールでも、タスク型とクエスト型では使い方が根本的に異なる。

#### タスク型モジュールの特徴

- **効率的な処理を目指す**
  - 入力→処理→出力が明確
  - 最適化が目標
  - エラーは避けるべきもの

- **例：在庫管理モジュール**
  - 在庫数を正確に管理
  - 規定値を下回ったら自動発注
  - 効率的で予測可能

#### クエスト型モジュールの特徴

- **探求、相関発見を目指す**
  - 「なぜ」を問う
  - 予想外の発見を歓迎
  - エラーは新しい道

- **例：在庫探索モジュール**
  - なぜこの商品が買われたのか
  - どんな組み合わせが生まれるか
  - 季節性、顧客の購買パターン、関連商品の相関を発見

### 2.4 プロンプト設計による違い

**同じ在庫管理システムでも、プロンプトで変わる**

**タスク型プロンプト：**
```
在庫が規定値を下回ったら発注してください
```
→ 決められた処理を実行

**クエスト型プロンプト：**
```
在庫の動きから、顧客の購買パターン、季節性、
関連商品の相関を見つけてください。
予想外の発見があれば報告してください
```
→ 探索と発見を促す

**同じモジュール、異なる使い方。**

これが、秘密道具駆動設計の柔軟性だ。モジュールは同じでも、プロンプト（使い方の指示）によって、タスク型にもクエスト型にもなる。

### 2.5 組み合わせの創発性

**事前に「正解」を設計する必要はない**

従来のソフトウェア設計では、すべてのパターンを事前に想定し、設計する必要があった。

秘密道具駆動設計では、そうではない。

- 試行する
- 評価する
- 有用なパターンを採用する

**生物の進化と同じだ。**

すべての組み合わせを試し、環境に適応したものが生き残る。

**LLMによる動的な組み合わせ判断**

LLMは、状態と目的に応じて、どのモジュールをどの順序で組み合わせるかを判断する。

- 現在の状況を分析
- 目的を理解
- 利用可能なモジュールを検索
- 最適な組み合わせを選択
- 実行
- 結果を評価
- 次回に活かす

**即興的コーディネーター**

ジャズのセッションのように、その場で最適な組み合わせを創り出す。固定的な楽譜（ワークフロー）ではなく、状況に応じた即興（動的な組み合わせ）。

これが、クエスト型設計の真髄だ。

---

## 第3章：具体的な実装の基盤

### 3.1 既存の技術スタック

**現代のソフトウェア開発の基盤**

秘密道具駆動設計は、既存の技術を活用する。

- **npm/yarn**：JavaScriptパッケージ
- **pip**：Pythonパッケージ
- **MCP（Model Context Protocol）**：LLMの統合
- **RESTful API、GraphQL**：外部サービスとの連携

**これらは既に存在している。**

未来デパートは既に稼働している。世界中の開発者が、日々新しいモジュールを公開している。

### 3.2 問題は使い方

**固定的なワークフローで組み合わせている**

既存のパッケージマネージャーやAPIは、タスク型で使われている。

- 事前に依存関係を定義
- package.jsonに記述
- 決められた順序で実行

**クエスト駆動で使っていない**

秘密道具駆動設計では、動的に取得し、組み合わせる。

- 状況に応じてモジュールを検索
- その場で取得
- 動的に組み合わせ
- 結果を評価

**Four-dimensional Pocket as a Service**

四次元ポケットをサービスとして提供する。ユーザー（のび太）は要望を伝えるだけ。システム（ドラえもん）が適切なモジュール（秘密道具）を探し、組み合わせ、提供する。

### 3.3 MCPの役割

**MCP（Model Context Protocol）とは**

AnthropicがClaude向けに開発した、LLMとツール/モジュール間の通信規格。

- JSON-RPCベース
- 標準化されたインターフェース
- ツールの動的な取得と実行

**四次元ポケットそのものだ。**

MCPは、LLMが外部のモジュールに動的にアクセスできるようにする。まさに、ドラえもんが四次元ポケットからその場で道具を取り出すように。

### 3.4 WebAssembly（WASM）の可能性

**「どこでもドア」的な性質**

WebAssemblyは、言語を超えた実行環境だ。

- ブラウザでも動く
- サーバーでも動く
- エッジでも動く
- モジュールが環境を選ばない

**これは、秘密道具駆動設計に理想的だ。**

モジュールは、どこでも動く。クライアント側でもサーバー側でも、同じモジュールが実行できる。まさに「どこでもドア」のように、場所を選ばない。

### 3.5 車輪の再発明を避ける——正しい再発明

**既存モジュールの活用**

npm、pip、MCP——すでに大量のモジュールがある。使えるものは使う。

**ただし、正しい車輪の再発明**

既存のものがタスク型だった場合、クエスト型に作り直す価値はある。

それは車輪の再発明ではなく、**「車輪の再発見」**だ。

同じ機能でも、タスク型とクエスト型では使い方が根本的に異なる。タスク型は効率を追求し、クエスト型は発見を追求する。

**例：検索モジュール**

- タスク型検索：キーワードに一致する結果を返す
- クエスト型検索：なぜこの結果が返ってきたのか、関連する意外なものは何か、を探索する

同じ「検索」でも、目的が違う。だから、再実装する価値がある。

---

## エピローグ：未解決の問題——意図的な穴

秘密道具駆動設計論は、完成していない。意図的に、いくつかの問題を残している。

### モジュールの選択基準

数千のモジュールがある中で、どれを選ぶか。

- 検索アルゴリズム
- フィルタリング基準
- 優先順位付けの方法

これは、読者・実践者に委ねる。状況によって最適な方法は異なるだろう。

### 組み合わせ爆発

10個のモジュールがあれば、組み合わせは膨大だ。

- どうやって有効な組み合わせを見つけるか
- 無駄な試行を減らすには
- 過去の成功パターンをどう活用するか

これも、意図的に残した空白だ。

### 動的インターフェース生成の実装

細胞膜のように、相手に応じてインターフェースを動的に生成する仕組み。

- LLMがその場でコードを生成するのか
- テンプレートを組み合わせるのか
- 型システムをどう扱うか

技術的には可能だが、最適な実装方法は探索中だ。

### 創発的組み合わせの評価基準

複数の組み合わせパターンを試行した時、「良い組み合わせ」をどう判定するか。

- 実行時間
- エネルギー効率
- ユーザー満足度
- 予想外の発見の価値

これらの指標をどう統合するか。単一の正解はない。

---

## 今後の展開

**検証が必要**

プロトタイプでの実証。組み合わせパターンの評価。実際の使用での学習。

**進化の方向性**

- モジュールの学習（どの組み合わせが有効だったか）
- コミュニティによるモジュール共有
- 自己進化するモジュールエコシステム

**秘密道具駆動設計は、始まったばかりだ。**

藤子先生が数百の秘密道具から無数の物語を生み出したように、私たちも無数のモジュールから、まだ見ぬプロジェクトを生み出していく。

**秘密道具があるから、物語が生まれる。**
**モジュールがあるから、創造が始まる。**

---

## 付録：関連概念

### ドラえもんの対応関係

- **秘密道具** = モジュール
- **4次元ポケット** = MCP/API
- **未来デパート** = npmレジストリ、GitHub
- **劇場版** = 状況に応じた動的な組み合わせ

### 関連する設計論

**クエスト駆動設計**
タスク型からクエスト型への文明転換。効率化ではなく、探索と発見が価値を生む社会の設計。

**メタプロンプト駆動設計**
Will（意思）の発現としてのクエスト。プロンプトが世界を変える。

**ゾーン駆動設計**
クエストが発生する場としてのゾーン。環境がクエストを触発する。

---

*作成日：2025-10-07*
*秘密道具駆動設計論 ver.1.0*
